# 30分钟K线支撑压力线计算说明

## 📊 当前实现总结

### 一、算法流程

30分钟K线的支撑压力线计算使用**常规震荡算法**（`_calculate_for_normal`），具体流程如下：

```
30分钟K线数据输入
    ↓
判断市场状态（创新高/新低）
    ↓
【30分钟周期】→ 使用常规震荡算法
    ↓
1. 判断趋势方向
2. 计算极值点（窗口大小=10）
3. 筛选支撑压力位
4. 返回结果
```

### 二、关键参数

| 参数 | 值 | 说明 |
|------|-----|------|
| **窗口大小** | `10` | 极值点查找窗口（30分钟周期固定值） |
| **边缘忽略数量** | `2` | 忽略最近2根K线（window_size // 4） |
| **价格判断方式** | `收盘价` | 使用 `max(open, close)` 判断波峰，`min(open, close)` 判断波谷 |
| **创新高/低判断周期** | `300` | 判断是否创新高/新低（但30分钟通常走常规算法） |

### 三、计算步骤详解

#### 步骤1：判断市场状态

```python
# 判断是否创新高（近300根K线）
is_new_top = self._is_new_top(klines, 300)
# 判断是否创新低（近300根K线）
is_new_bottom = self._is_new_bottom(klines, 300)
```

**注意**：对于30分钟K线，由于数据量大，通常不会触发创新高/新低判断，会走常规算法。

#### 步骤2：判断趋势方向（常规算法）

```python
direction = self._get_trend_direction(klines)
```

**趋势判断逻辑**：
- **反弹（direction=1）**：
  - 放量上涨（最近3根K线放量1.5倍 + 今日成交量>昨日 + 涨幅>3%）
  - 或从低点反弹（最近10根K线最低点 < 当前收盘价 + 涨幅>3%）

- **反转（direction=-1）**：
  - 放量下跌（最近3根K线放量1.5倍 + 跌幅<-3%）
  - 或从高点回落（最近10根K线最高点 > 当前收盘价 + 跌幅<-3%）

- **震荡（direction=0）**：
  - 不满足以上条件

#### 步骤3：计算极值点

```python
window_size = 10  # 30分钟周期固定值
side_ignored = 2  # 忽略最近2根K线

extreme_points = calculate_extreme_points(
    klines,
    window_size=10,
    peak_enabled=True,      # 查找波峰（压力位候选）
    valley_enabled=True,    # 查找波谷（支撑位候选）
    use_min_max=False,      # 使用收盘价，不用最高最低价
    side_ignored_count=2    # 忽略边缘数据
)
```

**极值点识别规则**：

1. **波峰识别（压力位）**：
   - 在窗口范围内（前后各5根K线），该点的 `max(open, close)` 必须是最高
   - 忽略最近2根K线的边缘数据

2. **波谷识别（支撑位）**：
   - 在窗口范围内（前后各5根K线），该点的 `min(open, close)` 必须是最低
   - 忽略最近2根K线的边缘数据

**窗口示意图**：
```
价格
 ^
 |     *           *  ← 波峰（压力位候选）
 |    / \         / \
 |   /   \       /   \
 |  /     \     /     \
 | /       \   /       \
 |/         \ /         \  ← 波谷（支撑位候选）
 |           *
 +-------------------------> 时间
    |---|   |   |---|
    左5根   当前  右5根
    (窗口大小=10)
```

#### 步骤4：筛选支撑压力位

```python
# 从极值点中筛选
last_support, support, pressure, last_pressure = pick_support_pressure_lines(
    extreme_points, 
    current_price, 
    period_type='30min',
    direction=direction
)
```

**筛选逻辑**：

1. **分离支撑位和压力位**：
   - 支撑位：极值点价格 < 当前价格
   - 压力位：极值点价格 > 当前价格

2. **排序**：
   - 支撑位：按价格从高到低排序（最接近当前价格的在前）
   - 压力位：按价格从低到高排序（最接近当前价格的在前）

3. **选择**：
   - **当前支撑位**：最接近当前价格且在下方的一个
   - **上一支撑位**：第二接近当前价格且在下方的一个
   - **当前压力位**：最接近当前价格且在上方的一个
   - **上一压力位**：第二接近当前价格且在上方的一个

### 四、算法特点

#### ✅ 优点

1. **适应性强**：根据趋势方向智能筛选
2. **去噪处理**：忽略边缘数据，减少干扰
3. **实时计算**：基于最新K线数据计算

#### ⚠️ 当前限制

1. **窗口固定**：30分钟周期窗口大小固定为10，没有根据趋势调整
2. **无不对称窗口**：没有像日线创新高/新低那样使用不对称窗口
3. **趋势判断简单**：仅基于最近3-10根K线判断趋势

### 五、与原始Java代码的差异

根据原始Java代码，30分钟K线应该有更复杂的处理：

1. **趋势判断**：使用均线趋势（`getBigTrendDirection`）
2. **不对称窗口**：
   - 上涨趋势：左窗口12，右窗口6，只找波谷（支撑位）
   - 下跌趋势：左窗口6，右窗口12，只找波峰（压力位）
   - 震荡趋势：使用双近算法（`calculateSupportLinesByDoubleNearAlgorithm`）

**当前实现**：简化版本，所有情况都使用对称窗口（10）同时查找波峰和波谷。

### 六、计算示例

假设有30分钟K线数据，当前价格50元：

```
步骤1：判断趋势
  - 最近3根K线放量1.5倍 ✓
  - 今日成交量 > 昨日成交量 ✓
  - 涨幅 = (50 - 48) / 48 = 4.2% > 3% ✓
  → direction = 1（反弹）

步骤2：计算极值点（窗口=10）
  - 波峰候选：[55, 53, 57, 54]
  - 波谷候选：[45, 47, 44, 46]

步骤3：筛选支撑压力位
  - 当前价格：50元
  - 支撑位候选（<50）：[47, 46, 45, 44] → 排序后：[47, 46, 45, 44]
  - 压力位候选（>50）：[53, 54, 55, 57] → 排序后：[53, 54, 55, 57]
  
  结果：
    - 当前支撑位：47元（最接近50且在下方）
    - 上一支撑位：46元
    - 当前压力位：53元（最接近50且在上方）
    - 上一压力位：54元
```

### 七、代码位置

- **主算法**：`backend/domain/services/support_pressure_algorithm.py`
- **调用位置**：`backend/infrastructure/external_apis/stock_analysis_repository_impl.py`

### 八、改进建议

如果需要更精确的30分钟K线计算，可以考虑：

1. **实现趋势判断**：使用均线判断大趋势方向
2. **不对称窗口**：根据趋势方向使用不同的窗口配置
3. **双近算法**：震荡时使用双窗口算法提高准确性

